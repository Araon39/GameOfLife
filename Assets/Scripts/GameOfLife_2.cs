using UnityEngine;
using UnityEngine.EventSystems;

public class GameOfLife_2 : MonoBehaviour
{
    public int rows = 20;
    public int columns = 20;
    public float cellSize = 1.0f;
    private bool[,] grid;
    private bool[,] nextGrid;
    private bool isSimulating = false;

    // Метод 'Start' инициализирует сетку, отображает начальные клетки и настраивает камеру.
    void Start()
    {
        // Устанавливаем камеру над полем
        Camera.main.transform.position = new Vector3((rows - 1) * cellSize / 2, 30, (columns - 1) * cellSize / 2);
        Camera.main.transform.rotation = Quaternion.Euler(90, 0, 0);
        // Инициализируем сетки для хранения текущего и следующего состояния клеток
        grid = new bool[rows, columns];
        nextGrid = new bool[rows, columns];
        // Отображаем начальное состояние сетки (все клетки мёртвые)
        DrawGrid();
    }

    void Update()
{
    // Начинаем симуляцию по нажатию пробела
    if (Input.GetKeyDown(KeyCode.Space))
    {
        isSimulating = !isSimulating;
        if (isSimulating)
        {
            InvokeRepeating("UpdateGrid", 1.0f, 0.5f);
        }
        else
        {
            CancelInvoke("UpdateGrid");
        }
    }

    // Позволяем пользователю щелчком мыши включать и выключать клетки
    // При клике в режиме паузы добавляем или удаляем кубики в сетке
    if (Input.GetMouseButtonDown(0) && !isSimulating)
    {
        Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition);
        RaycastHit hit;
        if (Physics.Raycast(ray, out hit))
        {
            int x = Mathf.FloorToInt(hit.point.x / cellSize);
            int y = Mathf.FloorToInt(hit.point.z / cellSize);
            if (x >= 0 && x < rows && y >= 0 && y < columns)
            {
                grid[x, y] = !grid[x, y];
                DrawGrid();
            }
        }
    }
}

    // Метод 'UpdateGrid' обновляет состояние всех клеток в соответствии с правилами "Игры жизни".
    void UpdateGrid()
    {
        for (int x = 0; x < rows; x++)
        {
            for (int y = 0; y < columns; y++)
            {
                // Подсчитываем количество живых соседей для текущей клетки
                int liveNeighbors = CountLiveNeighbors(x, y);
                // Правила обновления состояния клетки
                if (grid[x, y])
                {
                    // Живая клетка выживает, если у неё 2 или 3 живых соседа
                    nextGrid[x, y] = liveNeighbors == 2 || liveNeighbors == 3;
                }
                else
                {
                    // Мёртвая клетка оживает, если у неё ровно 3 живых соседа
                    nextGrid[x, y] = liveNeighbors == 3;
                }
            }
        }

        // Обмен сеток: текущая сетка становится следующей
        bool[,] temp = grid;
        grid = nextGrid;
        nextGrid = temp;

        // Визуализируем текущее состояние сетки
        DrawGrid();
    }

    // Метод 'CountLiveNeighbors' подсчитывает количество живых соседей для заданной клетки.
    int CountLiveNeighbors(int x, int y)
    {
        int count = 0;
        // Перебираем все соседние клетки, включая диагональные
        for (int i = -1; i <= 1; i++)
        {
            for (int j = -1; j <= 1; j++)
            {
                // Пропускаем саму клетку
                if (i == 0 && j == 0) continue;
                int nx = x + i;
                int ny = y + j;
                // Проверяем, что соседняя клетка находится внутри границ сетки и жива
                if (nx >= 0 && nx < rows && ny >= 0 && ny < columns && grid[nx, ny])
                {
                    count++;
                }
            }
        }
        return count;
    }

    // Метод 'DrawGrid' отвечает за визуализацию текущего состояния сетки в виде объектов на сцене.
    void DrawGrid()
    {
        // Создаём плоскость для отображения сетки
        GameObject plane;
        if (transform.Find("Plane") == null)
        {
            plane = GameObject.CreatePrimitive(PrimitiveType.Plane);
            plane.name = "Plane";
            plane.transform.position = new Vector3((rows - 1) * cellSize / 2, -0.1f, (columns - 1) * cellSize / 2);
            plane.transform.localScale = new Vector3(rows / 10.0f, 1, columns / 10.0f);
            plane.GetComponent<Renderer>().material.color = Color.gray;
            plane.transform.parent = transform;
        }
        else
        {
            plane = transform.Find("Plane").gameObject;
        }
        plane.transform.position = new Vector3((rows - 1) * cellSize / 2, -0.1f, (columns - 1) * cellSize / 2);
        plane.transform.localScale = new Vector3(rows / 10.0f, 1, columns / 10.0f);
        plane.GetComponent<Renderer>().material.color = Color.gray;
        plane.transform.parent = transform;
        // Удаляем все предыдущие объекты-клетки, чтобы обновить сцену
        foreach (Transform child in transform)
        {
            if (child.gameObject.name != "Plane")
            {
                Destroy(child.gameObject);
            }
        }

        // Создаём новые объекты-клетки для живых клеток
        for (int x = 0; x < rows; x++)
        {
            for (int y = 0; y < columns; y++)
            {
                if (grid[x, y])
                {
                    // Создаём куб для визуализации живой клетки
                    GameObject cell = GameObject.CreatePrimitive(PrimitiveType.Cube);
                    cell.GetComponent<Renderer>().material.color = Color.black;
                    cell.transform.position = new Vector3(x * cellSize, 0, y * cellSize);
                    cell.transform.parent = transform;
                }
            }
        }

    }
}